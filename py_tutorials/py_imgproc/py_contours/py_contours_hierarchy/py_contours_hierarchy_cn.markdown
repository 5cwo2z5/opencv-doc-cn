# 轮廓层次结构{#tutorial_py_contours_hierarchy_cn}

## 目标

这一次，我们将了解轮廓的层次结构，即轮廓中的亲子关系。

## 理论基础

在最近的几篇关于轮廓的教程中，我们已经讨论了OpenCV提供的几个与轮廓相关的函数。但是当我们使用`cv2.findContours()`函数在图像中寻找轮廓时，我们传递了一个参数**Contour Retrieval Mode**。我们通常传入`cv2.RETR_LIST`或`cv2.RETR_TREE`，它工作地很好。但是这个参数到底是什么意思呢？

另外，在输出中，我们得到了三个数组，第一个是图像，第二个是我们的轮廓，还有一个我们称为**hierarchy**的输出（请检查前面教程中的代码）。但是我们从来没有在任何地方使用这个hierarchy，那么这个hierarchy又是什么呢？它与前面提到的函数参数又有什么关系？

这就是我们在这篇文章中要了解的。

## 什么是层次结构？

通常我们使用`cv2.findContours()`函数来检测图像中的对象，对吧？有时物体位于不同的位置。但在某些情况下，一些轮廓在其他轮廓的内部。就像嵌套的形状。在这种情况下，我们称外面的轮廓为**父轮廓**，里面的轮廓为**子轮廓**。这样，图像中的轮廓彼此之间会有一些关系。我们可以指定轮廓是如何相互联系的，就像它是是其他轮廓的子轮廓还是父轮廓等等。

这种关系的表示称为**层次结构（Hierarchy）**。

看下面的示例图片：

![image](images/hierarchy.png)

在这个图像中，有几个我从**0-5**编号的形状。 2和2a表示最外面方形的外部和内部轮廓。

这里，轮廓0,1,2是**外部的或者最外面的**。我们可以说，他们在**第0层**中，或是在**同一个层次上**。

接下来是**轮廓2a**。它可以被认为是**轮廓2的子轮廓**（或者相反，轮廓2是轮廓2a的**父轮廓**）。所以它在**第1层**。类似地，轮廓3是轮廓2的子轮廓，并且进入下一层。最后轮廓4,5是轮廓3a的子轮廓，他们进入最后一个层次。从我对盒子进行编号的方式来看，我会说轮廓4是轮廓3a的第一个子轮廓（如果编号方式不同，也可以是轮廓5）。

我写出了这些东西来方便我们理解**相同的层次**，**外部轮廓**，**子轮廓**，**父轮廓**，**第一个子轮廓**等术语。现在让我们来看看OpenCV中的轮廓层次。

## OpenCV中的层次表示

因此，每个轮廓都有自己的信息，包括它是什么层次，谁是它的子轮廓，谁是它的父轮廓等。OpenCV将其表示为一个包含四个值的数组：`[Next, Previous, First_Child, Parent]`

<center>“Next表示相同层级中的下一个轮廓。”</center>

例如，在我们的图片中取轮廓0。谁是同一级别中的下一个轮廓？是轮廓1。因此，函数简单地返回 `Next = 1`。类似于轮廓1，接下来是轮廓2。所以`Next = 2`。

轮廓2呢？在同一级别中没有下一个轮廓。简单地说，函数将会返回`Next = -1`。那轮廓4呢？它与轮廓5处于同一层次。所以它的下一个轮廓是轮廓5，所以`Next = 5`。

<center>“Previous表示相同层级中的上一个轮廓。”</center>

和上面一样。轮廓1相同层级中的上一个轮廓是轮廓0。对于轮廓2也是类似的，结果是轮廓1。而对于轮廓0，没有上一个轮廓了，所以将会返回-1。

<center>“First_Child表示它的第一个子轮廓。”</center>

这不需要任何解释。对于轮廓2，子轮廓是轮廓2a。因此将获取到轮廓2a的索引。轮廓3a呢？它有两个子轮廓。但我们只取第一个子轮廓。它是轮廓4。所以对于轮廓3a来说`First_Child = 4`。

<center>“Parent表示其父轮廓的索引。”</center>

它与`First_Child`相对。对于轮廓4和轮廓5，父轮廓是轮廓3a。对于轮廓3a，它是轮廓3等等。

如果没有子轮廓或父轮廓，则该字段取-1。

所以现在我们知道了OpenCV中使用的层次样式，我们可以在上面给出的图像的帮助下来看看OpenCV中的轮廓检索模式。即像`cv2.RETR_LIST`，`cv2.RETR_TREE`，`cv2.RETR_CCOMP`，`cv2.RETR_EXTERNAL`这样的标志是什么意思？

## 轮廓检索模式

1. `RETR_LIST`

   这是四个标志中最简单的（从解释的角度来看）。它只是找到所有的轮廓，但不会创建任何父子关系。父母和孩子在这个规则下是平等的，他们只是轮廓。即它们都属于同一层级。

   所以在这里，层次数组中的第三和第四项总是-1。显然，Next和Previous将具有相应的值。你可以自己检查验证一下。

   下面是我得到的结果，每一行都是相应轮廓的层次结构细节。例如，第一行对应于轮廓0。下一个轮廓是轮廓1，因此，`Next = 1`。没有上一个的轮廓，所以`Previous = -1`。而其余的两个，正如之前所说，它是-1。

   ```python
   >>> hierarchy
   >>> array([[[ 1, -1, -1, -1],
           [ 2,  0, -1, -1],
           [ 3,  1, -1, -1],
           [ 4,  2, -1, -1],
           [ 5,  3, -1, -1],
           [ 6,  4, -1, -1],
           [ 7,  5, -1, -1],
           [-1,  6, -1, -1]]])
   ```

   如果您不使用任何层次结构功能，这是在您的代码中使用的好选择。

2. `RETR_EXTERNAL`

   如果你使用这个标志，它只返回最外面的轮廓。所有的子轮廓都会被忽略。我们可以说，在这种情况下，只有每个家庭的老大才能得到照顾。它不关心其他家庭成员:)。

   那么，在我们的图片中，有多少最外面的轮廓？即在层级0的轮廓？只有3个，即轮廓0,1,2，对吗？现在尝试使用此标志来查找轮廓。在这里，每个元素的值与上面相同。将其与以上结果进行比较。以下是我得到的：

   ```python
   >>> hierarchy
   >>> array([[[ 1, -1, -1, -1],
           [ 2,  0, -1, -1],
           [-1,  1, -1, -1]]])
   ```

   如果只想提取外轮廓，则可以使用此标志。在某些情况下可能会有用。

3. `RETR_CCOMP`

   该标志检索所有的轮廓，并将它们安排到2级层次结构中。即对象的外部轮廓（即其边界）被放置在层级1中。对象内的孔的轮廓（如果有的话）被放置在层次结构2中。如果孔的内部有任何物体，其轮廓会被重新放置在层次1中。而它内部的孔在二级，以此类推。

   只要考虑在黑色背景上的“大的白色的零字符”的形象。零的外圈属于第一层次，零的内圈属于第二层次。

   我们可以用一个简单的图像来解释它。在这里，我已经用红色标出了轮廓的顺序，用绿色标出了它们的层次（1或者2）。顺序与OpenCV检测轮廓的顺序相同。

   ![image](images/ccomp_hierarchy.png)

   ​

   考虑第一个轮廓，即轮廓0。它处于层次结构1。它有两个孔，轮廓1和2，属于等级2。因此，对于轮廓0，同一层级中的下一轮廓是轮廓3。没有上一个轮廓。其第一个是子轮廓是等级2中的轮廓1。它没有父轮廓，因为它在层次1中。所以它的hierarchy数组是`[3, -1, 1, -1]`。

   现在看轮廓1。它在层次2中。下一个在相同的层次（在轮廓1的父轮廓下）是轮廓2。没有上一个轮廓。没有子轮廓，但父轮廓是轮廓0。所以数组是`[2, -1, -1, 0]`。

   同样对于轮廓2：它在层次2中。轮廓0下的同一层次中没有下一个轮廓。所以没有`Next`。上一个轮廓是轮廓1。没有子轮廓，父轮廓是轮廓0。所以数组是`[-1, 1, -1, 0]`。

   轮廓3：层次1中的下一个轮廓是轮廓5。上一个是轮廓0。子轮廓是轮廓4，没有父轮廓。所以数组是`[5, 0, 4，-1]`。

   轮廓4：在轮廓3下的层次2中，它没有兄弟姐妹。所以没有上一个轮廓，没有下一个轮廓，没有孩子，父轮廓是轮廓3。所以数组是`[-1, -1, -1, 3]`。

   剩下的你可以自己推断。这是我得到的最终结果：

   ```python
   >>> hierarchy
   >>> array([[[ 3, -1,  1, -1],
           [ 2, -1, -1,  0],
           [-1,  1, -1,  0],
           [ 5,  0,  4, -1],
           [-1, -1, -1,  3],
           [ 7,  3,  6, -1],
           [-1, -1, -1,  5],
           [ 8,  5, -1, -1],
           [-1,  7, -1, -1]]])
   ```

   ​

   4. `RETR_TREE`

      这是最后一个“完美先生”。它检索所有的轮廓，并创建一个完整的家庭层次列表。它会告诉你爷爷，父亲，儿子，孙子是谁，甚至更多... :)。

      例如，把上面的图像重新用`cv2.RETR_TREE`进行轮廓检测，按照OpenCV给出的结果对轮廓重新排序并分析。再一次，红色字母给出了轮廓号，绿色字母给出了层次结构的顺序。

      ![image](images/tree_hierarchy.png)

      看轮廓0：它在层次结构0中。相同层次中的下一个轮廓是轮廓-。没有上一个轮廓。孩子是轮廓1。没有父轮廓。所以数组是`[7,-1,1,-1]`。

      看轮廓2：它在层次1。没有在同一级别的轮廓。没有上一个轮廓。子轮廓是轮廓3。父轮廓是轮廓1。所以数组是`[-1,-1,3,1]`。

      剩下的可以自己试试。以下是完整的结果：

      ```python
      >>> hierarchy
      >>> array([[[ 7, -1,  1, -1],
              [-1, -1,  2,  0],
              [-1, -1,  3,  1],
              [-1, -1,  4,  2],
              [-1, -1,  5,  3],
              [ 6, -1, -1,  4],
              [-1,  5, -1,  4],
              [ 8,  0, -1, -1],
              [-1,  7, -1, -1]]])
      ```

      ​

