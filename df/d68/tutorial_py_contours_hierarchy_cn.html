<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>OpenCV: 轮廓层次结构</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" async src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">3.3.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<script type="text/javascript">
//<![CDATA[
function getLabelName(innerHTML) {
    var str = innerHTML.toLowerCase();
    // Replace all '+' with 'p'
    str = str.split('+').join('p');
    // Replace all ' ' with '_'
    str = str.split(' ').join('_');
    // Replace all '#' with 'sharp'
    str = str.split('#').join('sharp');
    // Replace other special characters with 'ascii' + code
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (!(charCode == 95 || (charCode > 96 && charCode < 123) || (charCode > 47 && charCode < 58)))
            str = str.substr(0, i) + 'ascii' + charCode + str.substr(i + 1);
    }
    return str;
}
function addToggle() {
    var $getDiv = $('div.newInnerHTML').last();
    var buttonName = $getDiv.html();
    var label = getLabelName(buttonName.trim());
    $getDiv.attr("title", label);
    $getDiv.hide();
    $getDiv = $getDiv.next();
    $getDiv.attr("class", "toggleable_div label_" + label);
    $getDiv.hide();
}
//]]>
</script>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'搜索');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../index.html">OpenCV 官方文档中文翻译（基于V3.3.0）</a></li><li class="navelem"><a class="el" href="../../d5/d29/tutorial_py_table_of_contents_imgproc_cn.html">OpenCV中的图像处理</a></li><li class="navelem"><a class="el" href="../../d4/dd5/tutorial_py_table_of_contents_contours_cn.html">OpenCV中的轮廓</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">轮廓层次结构 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>目标</h2>
<p>这一次，我们将了解轮廓的层次结构，即轮廓中的亲子关系。</p>
<h2>理论基础</h2>
<p>在最近的几篇关于轮廓的教程中，我们已经讨论了OpenCV提供的几个与轮廓相关的函数。但是当我们使用<code>cv2.findContours()</code>函数在图像中寻找轮廓时，我们传递了一个参数**Contour Retrieval Mode**。我们通常传入<code>cv2.RETR_LIST</code>或<code>cv2.RETR_TREE</code>，它工作地很好。但是这个参数到底是什么意思呢？</p>
<p>另外，在输出中，我们得到了三个数组，第一个是图像，第二个是我们的轮廓，还有一个我们称为**hierarchy**的输出（请检查前面教程中的代码）。但是我们从来没有在任何地方使用这个hierarchy，那么这个hierarchy又是什么呢？它与前面提到的函数参数又有什么关系？</p>
<p>这就是我们在这篇文章中要了解的。</p>
<h2>什么是层次结构？</h2>
<p>通常我们使用<code>cv2.findContours()</code>函数来检测图像中的对象，对吧？有时物体位于不同的位置。但在某些情况下，一些轮廓在其他轮廓的内部。就像嵌套的形状。在这种情况下，我们称外面的轮廓为**父轮廓**，里面的轮廓为**子轮廓**。这样，图像中的轮廓彼此之间会有一些关系。我们可以指定轮廓是如何相互联系的，就像它是是其他轮廓的子轮廓还是父轮廓等等。</p>
<p>这种关系的表示称为**层次结构（Hierarchy）**。</p>
<p>看下面的示例图片：</p>
<div class="image">
<img src="../../images/hierarchy.png" alt="image"/>
</div>
<p>在这个图像中，有几个我从**0-5**编号的形状。 2和2a表示最外面方形的外部和内部轮廓。</p>
<p>这里，轮廓0,1,2是**外部的或者最外面的**。我们可以说，他们在**第0层**中，或是在**同一个层次上**。</p>
<p>接下来是**轮廓2a**。它可以被认为是**轮廓2的子轮廓**（或者相反，轮廓2是轮廓2a的**父轮廓**）。所以它在**第1层**。类似地，轮廓3是轮廓2的子轮廓，并且进入下一层。最后轮廓4,5是轮廓3a的子轮廓，他们进入最后一个层次。从我对盒子进行编号的方式来看，我会说轮廓4是轮廓3a的第一个子轮廓（如果编号方式不同，也可以是轮廓5）。</p>
<p>我写出了这些东西来方便我们理解**相同的层次**，**外部轮廓**，**子轮廓**，**父轮廓**，**第一个子轮廓**等术语。现在让我们来看看OpenCV中的轮廓层次。</p>
<h2>OpenCV中的层次表示</h2>
<p>因此，每个轮廓都有自己的信息，包括它是什么层次，谁是它的子轮廓，谁是它的父轮廓等。OpenCV将其表示为一个包含四个值的数组：<code>[Next, Previous, First_Child, Parent]</code></p>
<center>“Next表示相同层级中的下一个轮廓。”</center><p>例如，在我们的图片中取轮廓0。谁是同一级别中的下一个轮廓？是轮廓1。因此，函数简单地返回 <code>Next = 1</code>。类似于轮廓1，接下来是轮廓2。所以<code>Next = 2</code>。</p>
<p>轮廓2呢？在同一级别中没有下一个轮廓。简单地说，函数将会返回<code>Next = -1</code>。那轮廓4呢？它与轮廓5处于同一层次。所以它的下一个轮廓是轮廓5，所以<code>Next = 5</code>。</p>
<center>“Previous表示相同层级中的上一个轮廓。”</center><p>和上面一样。轮廓1相同层级中的上一个轮廓是轮廓0。对于轮廓2也是类似的，结果是轮廓1。而对于轮廓0，没有上一个轮廓了，所以将会返回-1。</p>
<center>“First_Child表示它的第一个子轮廓。”</center><p>这不需要任何解释。对于轮廓2，子轮廓是轮廓2a。因此将获取到轮廓2a的索引。轮廓3a呢？它有两个子轮廓。但我们只取第一个子轮廓。它是轮廓4。所以对于轮廓3a来说<code>First_Child = 4</code>。</p>
<center>“Parent表示其父轮廓的索引。”</center><p>它与<code>First_Child</code>相对。对于轮廓4和轮廓5，父轮廓是轮廓3a。对于轮廓3a，它是轮廓3等等。</p>
<p>如果没有子轮廓或父轮廓，则该字段取-1。</p>
<p>所以现在我们知道了OpenCV中使用的层次样式，我们可以在上面给出的图像的帮助下来看看OpenCV中的轮廓检索模式。即像<code>cv2.RETR_LIST</code>，<code>cv2.RETR_TREE</code>，<code>cv2.RETR_CCOMP</code>，<code>cv2.RETR_EXTERNAL</code>这样的标志是什么意思？</p>
<h2>轮廓检索模式</h2>
<ol type="1">
<li><p class="startli"><code>RETR_LIST</code></p>
<p class="startli">这是四个标志中最简单的（从解释的角度来看）。它只是找到所有的轮廓，但不会创建任何父子关系。父母和孩子在这个规则下是平等的，他们只是轮廓。即它们都属于同一层级。</p>
<p class="startli">所以在这里，层次数组中的第三和第四项总是-1。显然，Next和Previous将具有相应的值。你可以自己检查验证一下。</p>
<p class="startli">下面是我得到的结果，每一行都是相应轮廓的层次结构细节。例如，第一行对应于轮廓0。下一个轮廓是轮廓1，因此，<code>Next = 1</code>。没有上一个的轮廓，所以<code>Previous = -1</code>。而其余的两个，正如之前所说，它是-1。</p>
</li>
</ol>
<div class="fragment"><div class="line">&gt;&gt;&gt; hierarchy</div><div class="line">&gt;&gt;&gt; array([[[ 1, -1, -1, -1],</div><div class="line">        [ 2,  0, -1, -1],</div><div class="line">        [ 3,  1, -1, -1],</div><div class="line">        [ 4,  2, -1, -1],</div><div class="line">        [ 5,  3, -1, -1],</div><div class="line">        [ 6,  4, -1, -1],</div><div class="line">        [ 7,  5, -1, -1],</div><div class="line">        [-1,  6, -1, -1]]])</div></div><!-- fragment --><p>如果您不使用任何层次结构功能，这是在您的代码中使用的好选择。</p>
<ol type="1">
<li><p class="startli"><code>RETR_EXTERNAL</code></p>
<p class="startli">如果你使用这个标志，它只返回最外面的轮廓。所有的子轮廓都会被忽略。我们可以说，在这种情况下，只有每个家庭的老大才能得到照顾。它不关心其他家庭成员:)。</p>
<p class="startli">那么，在我们的图片中，有多少最外面的轮廓？即在层级0的轮廓？只有3个，即轮廓0,1,2，对吗？现在尝试使用此标志来查找轮廓。在这里，每个元素的值与上面相同。将其与以上结果进行比较。以下是我得到的：</p>
</li>
</ol>
<div class="fragment"><div class="line">&gt;&gt;&gt; hierarchy</div><div class="line">&gt;&gt;&gt; array([[[ 1, -1, -1, -1],</div><div class="line">        [ 2,  0, -1, -1],</div><div class="line">        [-1,  1, -1, -1]]])</div></div><!-- fragment --><p>如果只想提取外轮廓，则可以使用此标志。在某些情况下可能会有用。</p>
<ol type="1">
<li><p class="startli"><code>RETR_CCOMP</code></p>
<p class="startli">该标志检索所有的轮廓，并将它们安排到2级层次结构中。即对象的外部轮廓（即其边界）被放置在层级1中。对象内的孔的轮廓（如果有的话）被放置在层次结构2中。如果孔的内部有任何物体，其轮廓会被重新放置在层次1中。而它内部的孔在二级，以此类推。</p>
<p class="startli">只要考虑在黑色背景上的“大的白色的零字符”的形象。零的外圈属于第一层次，零的内圈属于第二层次。</p>
<p class="startli">我们可以用一个简单的图像来解释它。在这里，我已经用红色标出了轮廓的顺序，用绿色标出了它们的层次（1或者2）。顺序与OpenCV检测轮廓的顺序相同。</p>
<div class="image">
<img src="../../images/ccomp_hierarchy.png" alt="image"/>
</div>
<p class="startli">​</p>
<p class="startli">考虑第一个轮廓，即轮廓0。它处于层次结构1。它有两个孔，轮廓1和2，属于等级2。因此，对于轮廓0，同一层级中的下一轮廓是轮廓3。没有上一个轮廓。其第一个是子轮廓是等级2中的轮廓1。它没有父轮廓，因为它在层次1中。所以它的hierarchy数组是<code>[3, -1, 1, -1]</code>。</p>
<p class="startli">现在看轮廓1。它在层次2中。下一个在相同的层次（在轮廓1的父轮廓下）是轮廓2。没有上一个轮廓。没有子轮廓，但父轮廓是轮廓0。所以数组是<code>[2, -1, -1, 0]</code>。</p>
<p class="startli">同样对于轮廓2：它在层次2中。轮廓0下的同一层次中没有下一个轮廓。所以没有<code>Next</code>。上一个轮廓是轮廓1。没有子轮廓，父轮廓是轮廓0。所以数组是<code>[-1, 1, -1, 0]</code>。</p>
<p class="startli">轮廓3：层次1中的下一个轮廓是轮廓5。上一个是轮廓0。子轮廓是轮廓4，没有父轮廓。所以数组是<code>[5, 0, 4，-1]</code>。</p>
<p class="startli">轮廓4：在轮廓3下的层次2中，它没有兄弟姐妹。所以没有上一个轮廓，没有下一个轮廓，没有孩子，父轮廓是轮廓3。所以数组是<code>[-1, -1, -1, 3]</code>。</p>
<p class="startli">剩下的你可以自己推断。这是我得到的最终结果：</p>
</li>
</ol>
<div class="fragment"><div class="line">&gt;&gt;&gt; hierarchy</div><div class="line">&gt;&gt;&gt; array([[[ 3, -1,  1, -1],</div><div class="line">        [ 2, -1, -1,  0],</div><div class="line">        [-1,  1, -1,  0],</div><div class="line">        [ 5,  0,  4, -1],</div><div class="line">        [-1, -1, -1,  3],</div><div class="line">        [ 7,  3,  6, -1],</div><div class="line">        [-1, -1, -1,  5],</div><div class="line">        [ 8,  5, -1, -1],</div><div class="line">        [-1,  7, -1, -1]]])</div></div><!-- fragment --><p>​</p>
<ol type="1">
<li><p class="startli"><code>RETR_TREE</code></p>
<p class="startli">这是最后一个“完美先生”。它检索所有的轮廓，并创建一个完整的家庭层次列表。它会告诉你爷爷，父亲，儿子，孙子是谁，甚至更多... :)。</p>
<p class="startli">例如，把上面的图像重新用<code>cv2.RETR_TREE</code>进行轮廓检测，按照OpenCV给出的结果对轮廓重新排序并分析。再一次，红色字母给出了轮廓号，绿色字母给出了层次结构的顺序。</p>
<div class="image">
<img src="../../images/tree_hierarchy.png" alt="image"/>
</div>
<p class="startli">看轮廓0：它在层次结构0中。相同层次中的下一个轮廓是轮廓-。没有上一个轮廓。孩子是轮廓1。没有父轮廓。所以数组是<code>[7,-1,1,-1]</code>。</p>
<p class="startli">看轮廓2：它在层次1。没有在同一级别的轮廓。没有上一个轮廓。子轮廓是轮廓3。父轮廓是轮廓1。所以数组是<code>[-1,-1,3,1]</code>。</p>
<p class="startli">剩下的可以自己试试。以下是完整的结果：</p>
<p class="startli">```python &gt;&gt;&gt; hierarchy &gt;&gt;&gt; array([[[ 7, -1, 1, -1], [-1, -1, 2, 0], [-1, -1, 3, 1], [-1, -1, 4, 2], [-1, -1, 5, 3], [ 6, -1, -1, 4], [-1, 5, -1, 4], [ 8, 0, -1, -1], [-1, 7, -1, -1]]]) ```</p>
<p class="startli">​ </p>
</li>
</ol>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
生成于 2018年 六月 30日 星期六 17:46:57 , 为 OpenCV使用  &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
<script type="text/javascript">
//<![CDATA[
function addButton(label, buttonName) {
    var b = document.createElement("BUTTON");
    b.innerHTML = buttonName;
    b.setAttribute('class', 'toggleable_button label_' + label);
    b.onclick = function() {
        $('.toggleable_button').css({
            border: '2px outset',
            'border-radius': '4px'
        });
        $('.toggleable_button.label_' + label).css({
            border: '2px inset',
            'border-radius': '4px'
        });
        $('.toggleable_div').css('display', 'none');
        $('.toggleable_div.label_' + label).css('display', 'block');
    };
    b.style.border = '2px outset';
    b.style.borderRadius = '4px';
    b.style.margin = '2px';
    return b;
}
function buttonsToAdd($elements, $heading, $type) {
    if ($elements.length === 0) {
        $elements = $("" + $type + ":contains(" + $heading.html() + ")").parent().prev("div.newInnerHTML");
    }
    var arr = jQuery.makeArray($elements);
    var seen = {};
    arr.forEach(function(e) {
        var txt = e.innerHTML;
        if (!seen[txt]) {
            $button = addButton(e.title, txt);
            if (Object.keys(seen).length == 0) {
                var linebreak1 = document.createElement("br");
                var linebreak2 = document.createElement("br");
                ($heading).append(linebreak1);
                ($heading).append(linebreak2);
            }
            ($heading).append($button);
            seen[txt] = true;
        }
    });
    return;
}
$("h2").each(function() {
    $heading = $(this);
    $smallerHeadings = $(this).nextUntil("h2").filter("h3").add($(this).nextUntil("h2").find("h3"));
    if ($smallerHeadings.length) {
        $smallerHeadings.each(function() {
            var $elements = $(this).nextUntil("h2,h3").filter("div.newInnerHTML");
            buttonsToAdd($elements, $(this), "h3");
        });
    } else {
        var $elements = $(this).nextUntil("h2").filter("div.newInnerHTML");
        buttonsToAdd($elements, $heading, "h2");
    }
});
$(".toggleable_button").first().click();
var $clickDefault = $('.toggleable_button.label_python').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
$clickDefault = $('.toggleable_button.label_cpp').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
//]]>
</script>
</body>
</html>
