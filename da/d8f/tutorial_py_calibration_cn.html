<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>OpenCV: 相机校准</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" async src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">3.3.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<script type="text/javascript">
//<![CDATA[
function getLabelName(innerHTML) {
    var str = innerHTML.toLowerCase();
    // Replace all '+' with 'p'
    str = str.split('+').join('p');
    // Replace all ' ' with '_'
    str = str.split(' ').join('_');
    // Replace all '#' with 'sharp'
    str = str.split('#').join('sharp');
    // Replace other special characters with 'ascii' + code
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (!(charCode == 95 || (charCode > 96 && charCode < 123) || (charCode > 47 && charCode < 58)))
            str = str.substr(0, i) + 'ascii' + charCode + str.substr(i + 1);
    }
    return str;
}
function addToggle() {
    var $getDiv = $('div.newInnerHTML').last();
    var buttonName = $getDiv.html();
    var label = getLabelName(buttonName.trim());
    $getDiv.attr("title", label);
    $getDiv.hide();
    $getDiv = $getDiv.next();
    $getDiv.attr("class", "toggleable_div label_" + label);
    $getDiv.hide();
}
//]]>
</script>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'搜索');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../index.html">OpenCV 官方文档中文翻译（基于V3.3.0）</a></li><li class="navelem"><a class="el" href="../../d1/df3/tutorial_py_table_of_contents_calib3d_cn.html">相机校准和3D重建</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">相机校准 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>目标</h2>
<p>在这个部分，</p>
<ul>
<li>我们将学习相机拍摄图像的畸变，相机的内在和外在参数等。</li>
<li>我们将学习找到这些参数，让畸变图像复原等。</li>
</ul>
<h2>基本知识</h2>
<p>现代的的便宜针孔相机引起了很多图像畸变。两个主要的畸变方式是径向畸变和切向畸变。</p>
<p>径向畸变会使直线出现弯曲。当我们离开图像的中心时，它的效果就更明显了。例如，下面显示了一个图像，棋盘的两个边缘用红线标出。但是你可以看到边框不是一条直线，与红线不匹配。所有预期中的直线都变得凸出来了。访问维基百科<a href="https://zh.wikipedia.org/wiki/畸變">畸变</a>页面了解更多详情。</p>
<div class="image">
<img src="../../images/calib_radial.jpg" alt="image"/>
</div>
<p>这个畸变表示如下：</p>
<p>$$ x_{distorted} = x( 1 + k_1 r^2 + k_2 r^4 + k_3 r^6) \ y_{distorted} = y( 1 + k_1 r^2 + k_2 r^4 + k_3 r^6)\ $$</p>
<p>类似地，另一种畸变是由于图像摄取镜头没有完全平行于成像平面对准而发生的切向畸变。因此，图像中的某些区域可能看起来比预期更近。它表示如下：</p>
<p>$$ x_{distorted} = x + [ 2p_1xy + p_2(r^2+2x^2)] \ y_{distorted} = y + [ p_1(r^2+ 2y^2)+ 2p_2xy] $$</p>
<p>总之，我们需要找到五个参数，称为失真系数，由下式给出：</p>
<p>$$ Distortion \; coefficients=(k_1 {10pt} k_2 {10pt} p_1 {10pt} p_2 {10pt} k_3) $$</p>
<p>除此之外，我们还需要找到更多的信息，例如相机的内部和外部参数。内在参数是相机专用的。它包括焦距（$f_x,f_y$），光学中心（$c_x, c_y$）等信息，也被称为摄像机矩阵。它只取决于相机，所以一旦被计算了出来，它可以被存储以备将来之用。它被表示为一个3x3矩阵：</p>
<p>$$ camera \; matrix =  [ {matrix} f_x &amp; 0 &amp; c_x \ 0 &amp; f_y &amp; c_y \ 0 &amp; 0 &amp; 1 {matrix}  ] $$</p>
<p>外部参数对应于将3D点的坐标转换为坐标系的旋转和平移向量。</p>
<p>对于立体应用，首先需要纠正这些失真。要找到所有这些参数，我们所要做的就是提供一些定义良好的图案的示例图像（例如国际象棋棋盘）。我们找到一些具体的点（在棋盘的方形的角上的点）。我们知道它在现实世界中的坐标，我们知道它在图像中的坐标。利用这些数据，可以在后台解决一些数学问题来解出失真系数。大概的过程就是这样。为了获得更好的结果，我们至少需要10组测试数据。</p>
<h2>代码</h2>
<p>如上所述，我们需要至少10个相机校准的测试数据组。 OpenCV附带一些国际象棋棋盘的图像（参见samples/cpp/left01.jpg - left14.jpg），所以我们会利用它。为了容易理解，我们现在只考虑棋盘的一个图像。相机校准所需的重要输入数据是一组三维真实世界点及其相应的二维图像点。 2D图像点是可以从图像中轻松找到的。 （这些图像点是两个黑方块在棋盘上相互接触的位置）</p>
<p>那么从现实世界空间的3D点呢？这些图像是从静态相机拍摄的，棋盘放置在不同的位置和方向。所以我们需要知道(X,Y,Z)的值。但是为了简单起见，我们可以让棋盘在XY平面上保持静止，（所以总是有Z = 0），摄像机也随之移动。现在我们只需要找到X，Y的值了，我们可以简单地把点标记为（0,0），（1,0），（2,0），… 这些坐标表示点的位置。在这种情况下，我们得到的结果将会是以棋盘格大小为单位长度的结果。如果我们知道每个方块的尺寸（比如说30平方毫米），我们可以通过(0,0),(30,0),(60,0)...这样的值，我们得到的结果是毫米。 （在使用OpenCV附带图像的情况下，我们不知道方块的尺寸，因为这些图像不是我们拍摄的，所以我们传入以1格为一个单位的尺寸）。</p>
<p>3D点称为**对象点**，2D点称为**图像点**。</p>
<h2>设置</h2>
<p>所以要在棋盘上找到图案，我们使用函数<code>cv2.findChessboardCorners()</code>。我们还需要传入我们在观察什么样的模式，如8x8网格，5x5网格等。在这个例子中，我们使用7x6网格。 （通常棋盘有8x8的方块和7x7的内部角点）。它返回角点和<code>retval</code>，如果成功找到了相应的模式，<code>retval</code>将是True。这些角落将按顺序排序（从左到右，从上到下）。</p>
<p>此函数可能无法在所有图像中找到所需的图案。所以一个好的选择是编写这样的代码：它启动相机，并检查每个帧，试图找到所需的模式。一旦找到了所需的模式，找到角落并将其存储在列表中。在检查下一帧之前还需要了一些时间，来在不同的方向调整我们的棋盘。继续这个过程，直到获得所需数量的好模式。即使在提供的示例中，我们也不确定在14张图片中，有多少是好的。所以我们读入所有的图像，并采取其中好的那些。</p>
<p>代替国际象棋棋盘，我们可以使用一些圆形网格，然后使用函数<code>cv2.findCirclesGrid()</code>来查找模式。据说使用圆形网格时所需的的图像数量较少。</p>
<p>一旦我们找到了角落，我们可以使用<code>cv2.cornerSubPix()</code>来提高它们的准确性。我们也可以使用<code>cv2.drawChessboardCorners()</code>来绘制模式。所有这些步骤都包含在下面的代码中：</p>
<div class="fragment"><div class="line">import numpy as np</div><div class="line">import cv2</div><div class="line">import glob</div><div class="line"></div><div class="line"># 确定精度</div><div class="line">criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)</div><div class="line"></div><div class="line"># 准备点的坐标 (0,0,0), (1,0,0), (2,0,0) ....,(6,5,0)</div><div class="line">objp = np.zeros((6*7,3), np.float32)</div><div class="line">objp[:,:2] = np.mgrid[0:7,0:6].T.reshape(-1,2)</div><div class="line"></div><div class="line"># 对象点和图像点</div><div class="line">objpoints = [] # 真实空间中的3d点</div><div class="line">imgpoints = [] # 图像平面中的2d点</div><div class="line"></div><div class="line">images = glob.glob(&#39;*.jpg&#39;)</div><div class="line"></div><div class="line">for fname in images:</div><div class="line">    img = cv2.imread(fname)</div><div class="line">    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</div><div class="line"></div><div class="line">    # 查找棋盘格点</div><div class="line">    ret, corners = cv2.findChessboardCorners(gray, (7,6), None)</div><div class="line"></div><div class="line">    # 如果找到了，将其优化并加入</div><div class="line">    if ret == True:</div><div class="line">        objpoints.append(objp)</div><div class="line"></div><div class="line">        corners2=cv2.cornerSubPix(gray,corners, (11,11), (-1,-1), criteria)</div><div class="line">        imgpoints.append(corners)</div><div class="line"></div><div class="line">        # 绘制显示角点</div><div class="line">        cv2.drawChessboardCorners(img, (7,6), corners2, ret)</div><div class="line">        cv2.imshow(&#39;img&#39;, img)</div><div class="line">        cv2.waitKey(500)</div><div class="line"></div><div class="line">cv2.destroyAllWindows()</div></div><!-- fragment --><p>下面显示了一个有模式的图案：</p>
<div class="image">
<img src="../../images/calib_pattern.jpg" alt="image"/>
</div>
<h2>校准</h2>
<p>所以现在我们有我们的目标点和图像点了，我们可以准备去校准相机了。为此我们使用函数<code>cv2.calibrateCamera()</code>。它返回相机矩阵，失真系数，旋转和平移向量等。</p>
<div class="fragment"><div class="line">ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::-1], None, None)</div></div><!-- fragment --><h2>复原失真图像</h2>
<p>我们已经得到了我们尝试要找到的东西。现在我们可以来复原一个扭曲过的图像。 OpenCV有两种方法，我们都将会看到。但在此之前，我们可以使用<code>cv2.getOptimalNewCameraMatrix()</code>根据一个自由缩放参数来细化相机矩阵。如果缩放参数$ = 0$，则返回不失真的图像，其中不需要的像素最少。所以它甚至可能会删除图像角落的一些像素。如果$ = 1$，所有像素都会保留，还会出现一些额外的黑色图像。它还会返回一个可用于裁剪结果的图像ROI。</p>
<p>所以我们拍一个新的图像（在这个例子中是left12.jpg，这是本章的第一个图像）</p>
<div class="fragment"><div class="line">img = cv2.imread(&#39;left12.jpg&#39;)</div><div class="line">h,  w = img.shape[:2]</div><div class="line">newcameramtx, roi=cv2.getOptimalNewCameraMatrix(mtx, dist, (w,h), 1, (w,h))</div></div><!-- fragment --><ol type="1">
<li><p class="startli">使用<code>cv2.undistort()</code></p>
<p class="startli">这是最简单的方法。只需调用该函数并使用上面获得的ROI裁剪结果即可。</p>
</li>
</ol>
<div class="fragment"><div class="line"># undistort</div><div class="line">dst = cv2.undistort(img, mtx, dist, None, newcameramtx)</div><div class="line"></div><div class="line"># 裁剪图像</div><div class="line">x, y, w, h = roi</div><div class="line">dst = dst[y:y+h, x:x+w]</div><div class="line">cv2.imwrite(&#39;calibresult.png&#39;, dst)</div></div><!-- fragment --><ol type="1">
<li><p class="startli">使用remapping</p>
<p class="startli">这是比较复杂的方法。首先需要找到一个从扭曲过的图片转换到未扭曲的图片的对应关系（函数），接着要应用<code>remap</code>函数。</p>
</li>
</ol>
<div class="fragment"><div class="line"># undistort</div><div class="line">mapx, mapy = cv2.initUndistortRectifyMap(mtx, dist, None, newcameramtx, (w,h), 5)</div><div class="line">dst = cv2.remap(img, mapx, mapy, cv2.INTER_LINEAR)</div><div class="line"></div><div class="line"># 裁剪图像</div><div class="line">x, y, w, h = roi</div><div class="line">dst = dst[y:y+h, x:x+w]</div><div class="line">cv2.imwrite(&#39;calibresult.png&#39;, dst)</div></div><!-- fragment --><p>两种方法的结果是一样的，看下面的结果：</p>
<div class="image">
<img src="../../images/calib_result.jpg" alt="image"/>
</div>
<p>你可以看到所有的边缘现在都是直的了。</p>
<p>现在你可以用Numpy中的写入文件的函数（<code>np.savez</code>, <code>np.savetxt</code>等）来将相机矩阵和畸变系数保存起来，以备未来使用了。</p>
<h2>反向投影误差</h2>
<p>反向投影误差可以很好地估计出找到的参数的确切程度。这应尽可能接近于零。给定内在的，扭曲的，旋转和平移矩阵，我们首先使用<code>cv2.projectPoints()</code>将对象点转换成图像点。然后我们计算我们的变换和角点搜索算法之间的绝对规范。为了找到平均误差，我们计算所有校准图像的误差的算术平均值。</p>
<div class="fragment"><div class="line">mean_error = 0</div><div class="line">for i in xrange(len(objpoints)):</div><div class="line">    imgpoints2, _ = cv2.projectPoints(objpoints[i], rvecs[i], tvecs[i], mtx, dist)</div><div class="line">    error = cv2.norm(imgpoints[i], imgpoints2, cv2.NORM_L2)/len(imgpoints2)</div><div class="line">    mean_error += error</div><div class="line"></div><div class="line">print( &quot;total error: {}&quot;.format(mean_error/len(objpoints)) )</div></div><!-- fragment --><h2>练习</h2>
<ul>
<li>尝试使用圆形网格进行摄像头校准。 </li>
</ul>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
生成于 2018年 六月 30日 星期六 17:46:57 , 为 OpenCV使用  &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
<script type="text/javascript">
//<![CDATA[
function addButton(label, buttonName) {
    var b = document.createElement("BUTTON");
    b.innerHTML = buttonName;
    b.setAttribute('class', 'toggleable_button label_' + label);
    b.onclick = function() {
        $('.toggleable_button').css({
            border: '2px outset',
            'border-radius': '4px'
        });
        $('.toggleable_button.label_' + label).css({
            border: '2px inset',
            'border-radius': '4px'
        });
        $('.toggleable_div').css('display', 'none');
        $('.toggleable_div.label_' + label).css('display', 'block');
    };
    b.style.border = '2px outset';
    b.style.borderRadius = '4px';
    b.style.margin = '2px';
    return b;
}
function buttonsToAdd($elements, $heading, $type) {
    if ($elements.length === 0) {
        $elements = $("" + $type + ":contains(" + $heading.html() + ")").parent().prev("div.newInnerHTML");
    }
    var arr = jQuery.makeArray($elements);
    var seen = {};
    arr.forEach(function(e) {
        var txt = e.innerHTML;
        if (!seen[txt]) {
            $button = addButton(e.title, txt);
            if (Object.keys(seen).length == 0) {
                var linebreak1 = document.createElement("br");
                var linebreak2 = document.createElement("br");
                ($heading).append(linebreak1);
                ($heading).append(linebreak2);
            }
            ($heading).append($button);
            seen[txt] = true;
        }
    });
    return;
}
$("h2").each(function() {
    $heading = $(this);
    $smallerHeadings = $(this).nextUntil("h2").filter("h3").add($(this).nextUntil("h2").find("h3"));
    if ($smallerHeadings.length) {
        $smallerHeadings.each(function() {
            var $elements = $(this).nextUntil("h2,h3").filter("div.newInnerHTML");
            buttonsToAdd($elements, $(this), "h3");
        });
    } else {
        var $elements = $(this).nextUntil("h2").filter("div.newInnerHTML");
        buttonsToAdd($elements, $heading, "h2");
    }
});
$(".toggleable_button").first().click();
var $clickDefault = $('.toggleable_button.label_python').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
$clickDefault = $('.toggleable_button.label_cpp').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
//]]>
</script>
</body>
</html>
